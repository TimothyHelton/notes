%%%
\subsection{Dependencies}
\begin{lstlisting}
pip install numpy
pip install scipy
pip install matplotlib
pip install pandas
pip install statsmodels
pip install patsy
\end{lstlisting}

%%%
\subsection{Import}
\begin{lstlisting}
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy import stats
import seaborn as sns
\end{lstlisting}

%%%
\subsection{Box Plot}

\begin{lstlisting}
# Box plot where whiskers include all points
sns.boxplot([data1, data2], whis=np.inf)

# Box plot on the horizontal axis
sns.boxplot([data1, data2], vert=False)
\end{lstlisting}

%%%
\subsection{Carpet Plot (Rug Plot)}
Places a stick for every entry in the data set.

\begin{lstlisting}
sns.rugplot(dataset)
plt.ylim(0, 1)

# Add histogram to carpet plot
plt.hist(dataset, alpha=0.3)
\end{lstlisting}

%%%
\subsection{Clustermap}
This is a heatmap that combines like values.

%
\subsubsection{col\_cluster}
If False the column will {\color{red}{not}} be clustered.

%
\subsubsection{row\_cluster}
If False the row will {\color{red}{not}} be clustered.

%
\subsubsection{standard\_scale}
If 0 the rows will be used to set the scale and if 1 the columns will be used.

%
\subsubsection{z\_score}
If True the data will be standardized by the Z score. (Z score subtracts the
mean and divide by standard deviation.)

\begin{lstlisting}
sns.clustermap(dataset)
\end{lstlisting}

%%%
\subsection{Combining Plot Styles}

\begin{lstlisting}
sns.distplot(dataset, bins=25, rug=True,
             kde_kws={'color': 'indianred', 'label': 'KDE'},
             hist_kws={'color': 'blue', 'label': 'HIST'},
             rug_kws={'color': 'green', 'label': 'Rug'})
\end{lstlisting}

%%%
\subsection{Correlation Plot}
This plot will make a heat map like plot displaying the correlation values
between variables.
\begin{lstlisting}
sns.corrplot(pandas_dataframe)
\end{lstlisting}

%%%
\subsection{Heatmaps}

%
\subsubsection{annot}
This argument will annotate the values used to calculate the heatmap to the map.

%
\subsubsection{center}
This argument sets the location on the heatmap where the location will be zero
for the color bar.

%
\subsubsection{Combination Plots}

\begin{lstlisting}
fig, (ax1, ax2) = plt.subplots(2, 1)

sns.barplot('field1', 'field2', dataset, ax=ax1)
sns.heatmap(dataset, cmap='Blues', cbar_kws={'orientation': 'horizontal'},
            ax=ax2)
\begin{lstlisting}

%
\subsubsection{fmt}
This argument will set the format of the annotation.

\begin{lstlisting}
sns.heatmap(dataset, annot=True, fmt='d')
\end{lstlisting}

%%%
\subsection{Histograms}

\begin{lstlisting}
# Matplotlib
plt.hist(data_set1, normed=True, alpha=0.5, bins=20)
plt.hist(data_set2, normed=True, alpha=0.5, bins=20)

# Seaborn
sns.jointplot(data_set1, data_set2, kind='hex')
\end{lstlisting}

%%%
\subsection{Kernel Density Estimation Plots (KDE)}

\subsubsection{Long Way}

\begin{lstlisting}
sns.rugplot(dataset)

x_min = dataset.min() - 2
x_max = dataset.max() + 2

x_axis = np.linspace(x_min, x_max, 100)

bandwidth = ((4 * dataset.std()**5) / 3 * len(dataset)))**0.2

kernel_list = []

for data_point in dataset:
    # Create a kernel for each point
    kernel = stats.norm(data_point, bandwidth).pdf(x_axis))
    kernel_list.append(kernel)

    # Scale for plotting
    kernel = kernel / kernel.max()
    kernel = kernel * 0.4

    plt.plot(x_axis, kernel, alpha=0.5)

plt.ylim(0, 1)

kde_sum = np.sum(kernel_list, axis=0)

fig = plt.plot(x_zxis, kde_sum)
sns.rugplot(dataset)

plt.yticks([])
plt.suptitle("Sum of the basis functions")
\end{lstlisting}

%
\subsubsection{Short Way}

\begin{lstlisting}
sns.rugplot(dataset)
sns.kdeplot(dataset, bw=bandwidth, label=label, shade=True)
\end{lstlisting}

%
\subsubsection{Cumulative Distribution Function}

\begin{lstlisting}
sns.kdeplot(dataset, cumulative=True)
\end{lstlisting}

%%%
\subsection{Regression Plots}
Plots fields of a dataset against each other.

%
\subsubsection{hue}
Allows the markers to be different symbols based on another variable.

%
\subsubsection{fit\_reg}
If this argument is False the regression line will be excluded.

%
\subsubsection{lowess}
If this argument is True a local regression will be applied.

%
\subsubsection{order}
This argument is the polynomial fit order for the regression line.

%
\subsubsection{reg\_plot}
Ths is the core function used by lmplot, and it can be used like any other
plot in seaborn to add regression lines to the figure.

\begin{lstlisting}
fig, (ax1, ax2) = plt.subplots(1, 2, sharey=True)

sns.regplot('field1', 'field2', dataset, ax=ax1)
sns.violinplot(dataset['field2'], dataset['field3'], color='Reds_r', ax=ax2)
\end{lstlisting}
%
\subsubsection{x\_jitter or y\_jitter}
Set this argument to a float to slightly space the points around the true value.
This allows ease of visulaization.

%
\subsubsection{x\_estimator}
This argument will be used to calculate the "estimation" value of each bin.
(Example: x\_estimator=np.mean)


\begin{lstlisting}
sns.lmplot('field_1', 'field_2', dataset, order=4, x_jitter=0.1,
           scatter_kws={'marker': 'o', 'color': 'indianred'},
           line_kws={'linewidth': 1, 'color': 'blue')
\end{lstlisting}

%%%
\subsection{Sample Datasets}

\begin{lstlisting}
dataset = sns.load_dataset('tips')
\end{lstlisting}

%%%
\subsection{Violin Plot}
Combine a KDE Plot with a Box Plot. This type of plot will distinguish between
data that is symmetric about zero or centered on zero.

\begin{lstlisting}
sns.violinplot([data1, data2], inner='stick')
\end{lstlisting}
